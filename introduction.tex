\chapter{Introduction}
\label{introduction}

Before we get into technical details I want to first sketch why a typed
language for smart contracts might be important.
Since the dawn of the internet there has been a growing need for fast and
secure transfer of money.
Cash transfers are simply out of the question nowadays with applications like
personal banking from the comfort of your home, online stores that have a wider
assortment than would be possible and practical in a single physical location
(Amazon, Alibaba), crowdfunding which enables creators to produce new and
interesting items with low risk since the investors are also the customers
(kickstarter, indiegogo) and a great many more wonderful things.
All of these would not be possible without fast and secure digital payments.

\section{Cryptocurrency}

The history of money is long and complicated and there's still no agreement
about why it came to be.
Some argue it was invented to resolve a problem with barter, that problem being
the coincidence of wants: if I have apples and want medicine and someone else
has medicine but wants milk, I'd have to somehow find a third party who wants
apples and has milk or maybe even more intermediate parties.
Others consider the origin of money to be the moment when the amount one owed
was quantified in gift economies and seen as a form of credit.

How money came to be is a topic for historians, we are concerned with the
interplay between money and the current trend to streamline everything through
the use of computers and the internet.
Physical coins and banknotes are very useful as a universal and compact
representation of value and they have sufficed for centuries as a convenient
method of payment.
The advent of the internet called for payments over such vast distances that
the physical transfer of money would be prohibitive.
Services like Visa and PayPal which function on the principle of credit thrived
in this ecosystem.
More recently cryptocurrencies have come forward as an alternative for digital
payments without the burden of things like interest that are associated with
credit.
From a practical viewpoint these cryptocurrencies are the digital equivalent
of coins and banknotes, even though technically a ledger based system resembles
the english tallies more than modern currencies.
People have been playing with the idea of cryptocurrencies for a relatively
long while but it wasn't until Bitcoin came around that the concept gained
practical relevance outside of research.

\section{Bitcoin}

This cryptocurrency carries the distinction of being the first that was
suitable for widespread use, mostly because it solved the problem of having
trust in a decentralized system.
The main problem that haunted earlier attempts at decentralized
cryptocurrencies was the double spending problem.
To prevent someone from essentially spending some money twice, Bitcoin
introduced a decentralized ledger.
Since every transaction has to be entered in the ledger, the second attempt at
spending the same currency can be detected and simply doesn't succeed.
This may seem like an obvious solution to the problem but having a trustworthy
distributed ledger is not as simple as it sounds.

Bitcoin keeps people honest by rewarding them for extending the ledger.
To prevent people from claiming a reward for extending a fake ledger there is a
rule in place that only the longest ledger or blockchain counts.
Since extending a blockchain requires a significant amount of computational
effort, as long as more than half of the participants are honest, the true
blockchain will eventually become the longest and only valid one.
Essentially, the thing that keeps the blockchain trustworthy is the
computational effort needed to extend it and the reason people are willing to
expend that effort is the reward.

\section{Ethereum}

Ethereum takes the idea of the blockchain a step further.
Bitcoin transactions actually include a script that determines who can redeem
the value in the transaction.
In Bitcoin this is used to enable things like provably unspendable transactions
or transactions that require multiple parties to provide a signature.
Ethereum takes this idea of scripts and expands it into smart contracts.
A smart contract is an entity in the ethereum network that can effect
transactions exactly like a person but it can also interact with other smart
contracts and execute it's programming.
This allows for transactions that implement voting, auctions or safe remote
purchases of goods.
The entire voting procedure could be made observable so it is transparent.
You could have open or blinded auctions with a guarantee that the winner pays
up by having everyone pay in advance while the beneficiary of the auction will
only be able to collect the highest bid after the auction finishes.
Remote purchases could be made safe by having the contract automatically escrow
an amount exceeding the price for the good from the buyer, when the buyer
receives the good they have to sanction the transaction of the appropriate
amount to the seller if they want to have the exceeding amount refunded.

\section{Solidity}

Since smart contracts are actually programs we need a programming language to
define them.
Currently the language Solidity is recommended by the Ethereum foundation but
alternatives exist like Serpent and LLL.
Solidity is inspired by Javascript and is a statically typed object-oriented
language, also referred to as contract-oriented because instead of defining
objects you define contracts.
Even though Solidity is still very young as a language it looks like the
developers do not intend to take advantage of a more advanced type system to
prevent exceptions at runtime.

There are four possible exceptional conditions on the Ethereum Virtual Machine.
Simply running out of \emph{gas} during execution.
Stack underflow, jumping to a bad destination and invalid opcodes are the other
possibilities.
In an attempt to minimize complexity all of these are treated as out of gas
exceptions by the EVM.

\section{Validity}

The goal of this thesis is to formalize a language for Ethereum's smart
contracts that statically guarantees an absence of the four possible exceptions
through the use of a more advanced type system.
